<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#161b22">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="CCM">
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/svg+xml" href="/icons/icon-192.svg">
  <link rel="apple-touch-icon" href="/icons/icon-192.svg">
  <title>Claude Code Manager</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f1117;
      color: #e1e4e8;
      min-height: 100vh;
      overflow-x: hidden;
    }

    header {
      background: #161b22;
      border-bottom: 1px solid #30363d;
      padding: 12px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    header h1 { font-size: 18px; font-weight: 600; color: #f0f6fc; }

    .header-right {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
    }

    .ws-status { display: flex; align-items: center; gap: 6px; }
    .ws-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: #f85149; transition: background 0.3s;
    }
    .ws-dot.connected { background: #3fb950; }

    .cost-summary { color: #3fb950; font-weight: 600; }

    /* -- Create Form -- */
    .create-form {
      background: #161b22;
      border-bottom: 1px solid #30363d;
      padding: 12px 24px;
    }

    .create-form.collapsed .form-body { display: none; }

    .form-toggle {
      background: none; border: none; color: #58a6ff; cursor: pointer;
      font-size: 14px; padding: 4px 0; font-weight: 500;
    }
    .form-toggle:hover { color: #79c0ff; }

    .form-body { margin-top: 12px; }

    .form-row {
      display: flex; gap: 12px; margin-bottom: 10px;
    }

    .form-row input[type="text"], .form-row select {
      background: #0d1117; border: 1px solid #30363d; border-radius: 6px;
      color: #e1e4e8; padding: 7px 12px; font-size: 14px;
    }
    .form-row input[type="text"] { flex: 1; }
    .form-row select { width: 130px; }

    textarea {
      width: 100%; min-height: 60px; background: #0d1117;
      border: 1px solid #30363d; border-radius: 6px; color: #e1e4e8;
      padding: 7px 12px; font-size: 14px; font-family: inherit;
      resize: vertical; margin-bottom: 10px;
    }

    .form-actions { display: flex; justify-content: space-between; align-items: center; }
    .form-actions .hint { font-size: 12px; color: #8b949e; }

    button {
      background: #238636; border: 1px solid #2ea043; border-radius: 6px;
      color: #fff; padding: 6px 14px; font-size: 13px; cursor: pointer;
      font-weight: 500; transition: background 0.15s;
    }
    button:hover { background: #2ea043; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button.danger { background: #da3633; border-color: #f85149; }
    button.danger:hover { background: #f85149; }
    button.secondary { background: #21262d; border-color: #30363d; }
    button.secondary:hover { background: #30363d; }

    /* -- Kanban Board -- */
    .kanban-board {
      display: flex;
      gap: 12px;
      padding: 16px 24px;
      overflow-x: auto;
      min-height: calc(100vh - 160px);
      align-items: flex-start;
    }

    .kanban-column {
      min-width: 260px;
      max-width: 300px;
      flex: 1;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
    }

    .column-header {
      padding: 12px 14px;
      border-bottom: 1px solid #30363d;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .column-title {
      font-size: 13px; font-weight: 600; text-transform: uppercase;
      letter-spacing: 0.5px; color: #8b949e;
    }

    .column-count {
      font-size: 12px; background: #21262d; color: #8b949e;
      border-radius: 10px; padding: 1px 8px; min-width: 22px;
      text-align: center;
    }

    .column-body {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 60px;
      flex: 1;
    }

    .column-empty {
      text-align: center; padding: 20px 8px; color: #484f58;
      font-size: 13px;
    }

    /* -- Task Card -- */
    .task-card {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 12px;
      cursor: pointer;
      transition: border-color 0.15s, box-shadow 0.15s;
    }
    .task-card:hover {
      border-color: #58a6ff;
      box-shadow: 0 0 0 1px #58a6ff33;
    }
    .task-card.selected {
      border-color: #58a6ff;
      box-shadow: 0 0 0 2px #58a6ff44;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 6px;
    }

    .card-id { font-size: 11px; color: #484f58; font-weight: 500; }
    .card-title { font-size: 14px; font-weight: 500; color: #f0f6fc; margin-bottom: 8px; }

    .card-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 12px;
      color: #8b949e;
    }

    .card-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }
    .card-actions button { padding: 3px 8px; font-size: 11px; }

    /* -- Badges -- */
    .badge {
      display: inline-block; padding: 1px 7px; border-radius: 10px;
      font-size: 11px; font-weight: 500;
    }
    .badge-pending     { background: #1f2328; color: #8b949e; border: 1px solid #30363d; }
    .badge-in_progress { background: #0d2644; color: #58a6ff; border: 1px solid #1f6feb; }
    .badge-review      { background: #2d1b00; color: #d29922; border: 1px solid #9e6a03; }
    .badge-completed   { background: #0d2d0d; color: #3fb950; border: 1px solid #238636; }
    .badge-failed      { background: #3d1214; color: #f85149; border: 1px solid #da3633; }
    .badge-cancelled   { background: #1f2328; color: #8b949e; border: 1px solid #30363d; }

    .badge-low    { background: #1f2328; color: #8b949e; }
    .badge-medium { background: #0d2644; color: #58a6ff; }
    .badge-high   { background: #2d1b00; color: #d29922; }
    .badge-urgent { background: #3d1214; color: #f85149; }

    .elapsed { color: #58a6ff; font-size: 11px; }

    /* -- Side Panel -- */
    .side-panel-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 200;
    }

    .side-panel {
      position: fixed; top: 0; right: 0; bottom: 0;
      width: min(600px, 90vw);
      background: #161b22;
      border-left: 1px solid #30363d;
      z-index: 201;
      display: flex;
      flex-direction: column;
      animation: slideIn 0.2s ease-out;
    }

    @keyframes slideIn {
      from { transform: translateX(100%); }
      to { transform: translateX(0); }
    }

    .panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-header h2 { font-size: 16px; color: #f0f6fc; }

    .panel-close {
      background: none; border: 1px solid #30363d; color: #8b949e;
      width: 28px; height: 28px; border-radius: 6px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      font-size: 16px;
    }
    .panel-close:hover { background: #21262d; color: #e1e4e8; }

    .panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    .task-detail { margin-bottom: 16px; }
    .task-detail label {
      font-size: 12px; color: #8b949e; text-transform: uppercase;
      letter-spacing: 0.5px; display: block; margin-bottom: 4px;
    }
    .task-detail .value {
      font-size: 14px; color: #e1e4e8;
    }
    .task-detail .prompt-text {
      background: #0d1117; border: 1px solid #30363d; border-radius: 6px;
      padding: 10px 12px; font-size: 13px; white-space: pre-wrap;
      max-height: 120px; overflow-y: auto;
    }

    .panel-actions {
      display: flex; gap: 8px; margin-bottom: 20px;
    }

    .log-section h3 {
      font-size: 13px; color: #8b949e; text-transform: uppercase;
      letter-spacing: 0.5px; margin-bottom: 10px;
      border-bottom: 1px solid #30363d; padding-bottom: 6px;
    }

    .log-entries {
      display: flex; flex-direction: column; gap: 4px;
    }

    .log-entry {
      font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      background: #0d1117;
      word-break: break-word;
    }

    .log-entry .log-time { color: #484f58; margin-right: 8px; }
    .log-entry .log-level-info { color: #58a6ff; }
    .log-entry .log-level-error { color: #f85149; }
    .log-entry .log-level-warn { color: #d29922; }
    .log-entry .log-msg { color: #e1e4e8; }

    .log-empty { color: #484f58; font-size: 13px; padding: 12px 0; }

    /* -- Plan Mode Toggle -- */
    .plan-toggle {
      display: flex; align-items: center; gap: 8px; font-size: 13px;
    }
    .plan-toggle input[type="checkbox"] {
      accent-color: #58a6ff; width: 16px; height: 16px; cursor: pointer;
    }
    .plan-toggle label { color: #8b949e; cursor: pointer; user-select: none; }
    .plan-toggle .plan-hint {
      font-size: 11px; color: #484f58; font-style: italic;
    }

    /* -- Multi-select (depends_on) -- */
    .depends-section { margin-bottom: 10px; }
    .depends-label {
      font-size: 12px; color: #8b949e; margin-bottom: 4px; display: block;
    }
    .depends-chips {
      display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px;
    }
    .dep-chip {
      display: inline-flex; align-items: center; gap: 4px;
      background: #0d2644; color: #58a6ff; border: 1px solid #1f6feb;
      border-radius: 12px; padding: 2px 10px; font-size: 12px;
    }
    .dep-chip button {
      background: none; border: none; color: #58a6ff; cursor: pointer;
      font-size: 14px; padding: 0; line-height: 1;
    }
    .dep-chip button:hover { color: #f85149; }
    .depends-select {
      background: #0d1117; border: 1px solid #30363d; border-radius: 6px;
      color: #e1e4e8; padding: 5px 8px; font-size: 13px; width: 100%;
    }

    /* -- Voice Input -- */
    .voice-row {
      display: flex; gap: 8px; align-items: flex-start; margin-bottom: 10px;
    }
    .voice-row textarea { flex: 1; margin-bottom: 0; }
    .voice-btn {
      background: #21262d; border: 1px solid #30363d; color: #8b949e;
      border-radius: 6px; width: 40px; height: 40px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      font-size: 18px; flex-shrink: 0; transition: all 0.15s;
    }
    .voice-btn:hover { background: #30363d; color: #e1e4e8; }
    .voice-btn.recording {
      background: #3d1214; border-color: #f85149; color: #f85149;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .voice-unsupported { display: none; }

    /* -- Template Dropdown -- */
    .template-row {
      display: flex; gap: 8px; margin-bottom: 10px; align-items: center;
    }
    .template-row select {
      flex: 1; background: #0d1117; border: 1px solid #30363d;
      border-radius: 6px; color: #e1e4e8; padding: 5px 8px; font-size: 13px;
    }
    .template-row button { padding: 5px 10px; font-size: 12px; }
    .template-row button.delete-tpl { background: #21262d; border-color: #30363d; }
    .template-row button.delete-tpl:hover { background: #da3633; border-color: #f85149; }

    /* -- Responsive -- */
    @media (max-width: 768px) {
      .kanban-board { padding: 12px; gap: 8px; }
      .kanban-column { min-width: 220px; }
      .form-row { flex-direction: column; }
      .form-row select { width: 100%; }
      .side-panel { width: 100vw; }
      .voice-row { flex-direction: row; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const COLUMNS = [
      { key: 'pending',     label: 'Pending' },
      { key: 'in_progress', label: 'In Progress' },
      { key: 'review',      label: 'Review' },
      { key: 'completed',   label: 'Completed' },
      { key: 'failed',      label: 'Failed' },
      { key: 'cancelled',   label: 'Cancelled' },
    ];

    const API = '/api';

    // -- Elapsed time helper --
    function formatElapsed(startedAt) {
      if (!startedAt) return '';
      const ms = Date.now() - new Date(startedAt).getTime();
      if (ms < 0) return '';
      const secs = Math.floor(ms / 1000);
      const mins = Math.floor(secs / 60);
      const hrs = Math.floor(mins / 60);
      if (hrs > 0) return `${hrs}h ${mins % 60}m`;
      if (mins > 0) return `${mins}m ${secs % 60}s`;
      return `${secs}s`;
    }

    // -- TaskCard Component --
    function TaskCard({ task, selected, onSelect }) {
      const [elapsed, setElapsed] = useState('');

      useEffect(() => {
        if (task.status !== 'in_progress' || !task.started_at) {
          setElapsed('');
          return;
        }
        setElapsed(formatElapsed(task.started_at));
        const iv = setInterval(() => setElapsed(formatElapsed(task.started_at)), 1000);
        return () => clearInterval(iv);
      }, [task.status, task.started_at]);

      const cost = task.cost_usd || 0;

      return (
        <div
          className={`task-card${selected ? ' selected' : ''}`}
          onClick={() => onSelect(task.id)}
        >
          <div className="card-header">
            <span className="card-id">#{task.id}</span>
            <span className={`badge badge-${task.priority}`}>{task.priority}</span>
          </div>
          <div className="card-title">{task.title}</div>
          <div className="card-meta">
            {cost > 0 && <span>${cost.toFixed(4)}</span>}
            {elapsed && <span className="elapsed">{elapsed}</span>}
          </div>
        </div>
      );
    }

    // -- KanbanColumn Component --
    function KanbanColumn({ column, tasks, selectedId, onSelect }) {
      const colTasks = tasks.filter(t => t.status === column.key);

      return (
        <div className="kanban-column">
          <div className="column-header">
            <span className="column-title">{column.label}</span>
            <span className="column-count">{colTasks.length}</span>
          </div>
          <div className="column-body">
            {colTasks.length === 0 ? (
              <div className="column-empty">No tasks</div>
            ) : (
              colTasks.map(t => (
                <TaskCard
                  key={t.id}
                  task={t}
                  selected={selectedId === t.id}
                  onSelect={onSelect}
                />
              ))
            )}
          </div>
        </div>
      );
    }

    // -- SidePanel Component --
    function SidePanel({ task, logs, onClose, onCancel, onRetry, onDelete }) {
      if (!task) return null;

      const logEndRef = useRef(null);
      useEffect(() => {
        if (logEndRef.current) {
          logEndRef.current.scrollIntoView({ behavior: 'smooth' });
        }
      }, [logs]);

      const cost = task.cost_usd || 0;
      const canCancel = task.status === 'pending' || task.status === 'in_progress';
      const canRetry = task.status === 'failed' || task.status === 'cancelled';
      const canDelete = task.status !== 'in_progress';

      return (
        <React.Fragment>
          <div className="side-panel-overlay" onClick={onClose} />
          <div className="side-panel">
            <div className="panel-header">
              <h2>#{task.id} {task.title}</h2>
              <button className="panel-close" onClick={onClose}>&times;</button>
            </div>
            <div className="panel-body">
              <div className="task-detail">
                <label>Status</label>
                <div className="value">
                  <span className={`badge badge-${task.status}`}>{task.status.replace('_', ' ')}</span>
                </div>
              </div>
              <div className="task-detail">
                <label>Priority</label>
                <div className="value">
                  <span className={`badge badge-${task.priority}`}>{task.priority}</span>
                </div>
              </div>
              {cost > 0 && (
                <div className="task-detail">
                  <label>Cost</label>
                  <div className="value">${cost.toFixed(4)}</div>
                </div>
              )}
              {task.input_tokens != null && (
                <div className="task-detail">
                  <label>Tokens</label>
                  <div className="value">
                    {task.input_tokens?.toLocaleString()} in / {task.output_tokens?.toLocaleString()} out
                  </div>
                </div>
              )}
              <div className="task-detail">
                <label>Created</label>
                <div className="value">{new Date(task.created_at).toLocaleString()}</div>
              </div>
              {task.started_at && (
                <div className="task-detail">
                  <label>Started</label>
                  <div className="value">{new Date(task.started_at).toLocaleString()}</div>
                </div>
              )}
              {task.completed_at && (
                <div className="task-detail">
                  <label>Completed</label>
                  <div className="value">{new Date(task.completed_at).toLocaleString()}</div>
                </div>
              )}
              <div className="task-detail">
                <label>Prompt</label>
                <div className="prompt-text">{task.prompt}</div>
              </div>
              {task.error && (
                <div className="task-detail">
                  <label>Error</label>
                  <div className="value" style={{color: '#f85149'}}>{task.error}</div>
                </div>
              )}

              <div className="panel-actions">
                {canCancel && (
                  <button className="danger" onClick={() => onCancel(task.id)}>Cancel</button>
                )}
                {canRetry && (
                  <button className="secondary" onClick={() => onRetry(task.id)}>Retry</button>
                )}
                {canDelete && (
                  <button className="danger" onClick={() => onDelete(task.id)}>Delete</button>
                )}
              </div>

              <div className="log-section">
                <h3>Logs</h3>
                <div className="log-entries">
                  {(!logs || logs.length === 0) ? (
                    <div className="log-empty">No logs yet.</div>
                  ) : (
                    logs.map((log, i) => {
                      const time = new Date(log.timestamp).toLocaleTimeString();
                      const levelClass = `log-level-${log.level}`;
                      return (
                        <div key={log.id || i} className="log-entry">
                          <span className="log-time">{time}</span>
                          <span className={levelClass}>[{log.level}]</span>{' '}
                          <span className="log-msg">{log.message}</span>
                        </div>
                      );
                    })
                  )}
                  <div ref={logEndRef} />
                </div>
              </div>
            </div>
          </div>
        </React.Fragment>
      );
    }

    // -- Template helpers (localStorage) --
    const TEMPLATE_KEY = 'claude-manager-templates';

    function loadTemplates() {
      try {
        const raw = localStorage.getItem(TEMPLATE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch { return []; }
    }

    function saveTemplates(templates) {
      localStorage.setItem(TEMPLATE_KEY, JSON.stringify(templates));
    }

    // -- Plan mode prompt prefix --
    const PLAN_PREFIX = `You are in PLAN MODE. Do NOT execute any code changes yet.

Instead:
1. Analyze the request carefully
2. Identify all files that need to be modified
3. Outline the implementation steps in detail
4. List potential risks or edge cases
5. Present the plan for human review

Only after the plan is approved will you proceed with execution.

---

`;

    // -- CreateForm Component --
    function CreateForm({ onCreated, tasks }) {
      const [collapsed, setCollapsed] = useState(true);
      const [title, setTitle] = useState('');
      const [prompt, setPrompt] = useState('');
      const [priority, setPriority] = useState('medium');
      const [planMode, setPlanMode] = useState(false);
      const [dependsOn, setDependsOn] = useState([]);
      const [submitting, setSubmitting] = useState(false);
      const [recording, setRecording] = useState(false);
      const [templates, setTemplates] = useState(loadTemplates);
      const recognitionRef = useRef(null);
      const textareaRef = useRef(null);

      const hasSpeech = typeof window !== 'undefined' &&
        ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window);

      const handleSubmit = useCallback(async () => {
        if (!title.trim() || !prompt.trim() || submitting) return;
        setSubmitting(true);
        try {
          const finalPrompt = planMode ? PLAN_PREFIX + prompt.trim() : prompt.trim();
          const body = {
            title: title.trim(),
            prompt: finalPrompt,
            priority,
            mode: planMode ? 'plan' : 'execute',
          };
          if (dependsOn.length > 0) body.depends_on = dependsOn;
          const resp = await fetch(`${API}/tasks`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (resp.ok) {
            setTitle('');
            setPrompt('');
            setPriority('medium');
            setPlanMode(false);
            setDependsOn([]);
            onCreated();
          }
        } catch (e) {
          console.error('Failed to create task:', e);
        } finally {
          setSubmitting(false);
        }
      }, [title, prompt, priority, planMode, dependsOn, submitting, onCreated]);

      useEffect(() => {
        const handler = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
            e.preventDefault();
            handleSubmit();
          }
        };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [handleSubmit]);

      // -- Voice input --
      const toggleVoice = useCallback(() => {
        if (recording && recognitionRef.current) {
          recognitionRef.current.stop();
          setRecording(false);
          return;
        }
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return;
        const recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = false;
        recognition.lang = 'en-US';
        recognition.onresult = (event) => {
          let transcript = '';
          for (let i = event.resultIndex; i < event.results.length; i++) {
            if (event.results[i].isFinal) {
              transcript += event.results[i][0].transcript;
            }
          }
          if (transcript) {
            setPrompt(prev => prev + (prev ? ' ' : '') + transcript.trim());
          }
        };
        recognition.onerror = () => setRecording(false);
        recognition.onend = () => setRecording(false);
        recognition.start();
        recognitionRef.current = recognition;
        setRecording(true);
      }, [recording]);

      // Cleanup recognition on unmount
      useEffect(() => {
        return () => {
          if (recognitionRef.current) recognitionRef.current.stop();
        };
      }, []);

      // -- depends_on handlers --
      const addDependency = useCallback((e) => {
        const id = parseInt(e.target.value, 10);
        if (id && !dependsOn.includes(id)) {
          setDependsOn(prev => [...prev, id]);
        }
        e.target.value = '';
      }, [dependsOn]);

      const removeDependency = useCallback((id) => {
        setDependsOn(prev => prev.filter(d => d !== id));
      }, []);

      // -- Template handlers --
      const loadTemplate = useCallback((e) => {
        const idx = parseInt(e.target.value, 10);
        if (isNaN(idx)) return;
        const tpl = templates[idx];
        if (tpl) {
          setTitle(tpl.title || '');
          setPrompt(tpl.prompt || '');
          setPriority(tpl.priority || 'medium');
          setPlanMode(tpl.planMode || false);
        }
        e.target.value = '';
      }, [templates]);

      const saveTemplate = useCallback(() => {
        if (!title.trim() && !prompt.trim()) return;
        const name = window.prompt('Template name:');
        if (!name) return;
        const newTpl = { name, title, prompt, priority, planMode };
        const updated = [...templates, newTpl];
        setTemplates(updated);
        saveTemplates(updated);
      }, [title, prompt, priority, planMode, templates]);

      const deleteTemplate = useCallback((idx) => {
        const updated = templates.filter((_, i) => i !== idx);
        setTemplates(updated);
        saveTemplates(updated);
      }, [templates]);

      // Available tasks for depends_on (exclude completed/cancelled)
      const availableTasks = tasks.filter(t =>
        !['completed', 'cancelled'].includes(t.status) && !dependsOn.includes(t.id)
      );

      return (
        <div className={`create-form${collapsed ? ' collapsed' : ''}`}>
          <button className="form-toggle" onClick={() => setCollapsed(!collapsed)}>
            {collapsed ? '+ New Task' : '- Hide Form'}
          </button>
          <div className="form-body">
            {/* Template row */}
            {templates.length > 0 && (
              <div className="template-row">
                <select onChange={loadTemplate} defaultValue="">
                  <option value="" disabled>Load template...</option>
                  {templates.map((tpl, i) => (
                    <option key={i} value={i}>{tpl.name}</option>
                  ))}
                </select>
                {templates.length > 0 && (
                  <button
                    className="delete-tpl"
                    onClick={() => {
                      const idx = window.prompt(`Delete template # (0-${templates.length - 1}):`);
                      if (idx !== null && !isNaN(parseInt(idx, 10))) deleteTemplate(parseInt(idx, 10));
                    }}
                    title="Delete a template"
                  >Del</button>
                )}
              </div>
            )}

            <div className="form-row">
              <input
                type="text"
                placeholder="Task title"
                value={title}
                onChange={e => setTitle(e.target.value)}
              />
              <select value={priority} onChange={e => setPriority(e.target.value)}>
                <option value="low">Low</option>
                <option value="medium">Medium</option>
                <option value="high">High</option>
                <option value="urgent">Urgent</option>
              </select>
              <div className="plan-toggle">
                <input
                  type="checkbox"
                  id="plan-mode"
                  checked={planMode}
                  onChange={e => setPlanMode(e.target.checked)}
                />
                <label htmlFor="plan-mode">Plan mode</label>
              </div>
            </div>

            {/* Prompt + voice */}
            <div className="voice-row">
              <textarea
                ref={textareaRef}
                placeholder={planMode
                  ? "Task prompt (Plan mode: Claude will analyze and plan before executing)"
                  : "Task prompt (what should Claude do?)"
                }
                value={prompt}
                onChange={e => setPrompt(e.target.value)}
              />
              {hasSpeech && (
                <button
                  className={`voice-btn${recording ? ' recording' : ''}`}
                  onClick={toggleVoice}
                  title={recording ? 'Stop recording' : 'Voice input'}
                  type="button"
                >
                  {recording ? '\u23F9' : '\uD83C\uDF99'}
                </button>
              )}
            </div>

            {/* Depends on */}
            <div className="depends-section">
              <span className="depends-label">Depends on</span>
              {dependsOn.length > 0 && (
                <div className="depends-chips">
                  {dependsOn.map(id => {
                    const t = tasks.find(t => t.id === id);
                    return (
                      <span key={id} className="dep-chip">
                        #{id}{t ? ` ${t.title}` : ''}
                        <button onClick={() => removeDependency(id)}>&times;</button>
                      </span>
                    );
                  })}
                </div>
              )}
              {availableTasks.length > 0 && (
                <select className="depends-select" onChange={addDependency} value="">
                  <option value="" disabled>Add dependency...</option>
                  {availableTasks.map(t => (
                    <option key={t.id} value={t.id}>#{t.id} {t.title} ({t.status})</option>
                  ))}
                </select>
              )}
            </div>

            <div className="form-actions">
              <div style={{display: 'flex', gap: '8px', alignItems: 'center'}}>
                <span className="hint">
                  {navigator.platform?.includes('Mac') ? 'Cmd' : 'Ctrl'}+Enter to submit
                </span>
                <button className="secondary" onClick={saveTemplate} type="button"
                  style={{padding: '4px 10px', fontSize: '12px'}}>
                  Save as template
                </button>
              </div>
              <button onClick={handleSubmit} disabled={submitting}>
                {submitting ? 'Creating...' : planMode ? 'Create Plan Task' : 'Create Task'}
              </button>
            </div>
          </div>
        </div>
      );
    }

    // -- App Component --
    function App() {
      const [tasks, setTasks] = useState([]);
      const [selectedId, setSelectedId] = useState(null);
      const [selectedTask, setSelectedTask] = useState(null);
      const [logs, setLogs] = useState([]);
      const [wsConnected, setWsConnected] = useState(false);
      const wsRef = useRef(null);

      // Fetch all tasks
      const fetchTasks = useCallback(async () => {
        try {
          const resp = await fetch(`${API}/tasks`);
          const data = await resp.json();
          setTasks(data);
        } catch (e) {
          console.error('Failed to fetch tasks:', e);
        }
      }, []);

      // Fetch single task detail + logs
      const fetchTaskDetail = useCallback(async (id) => {
        try {
          const resp = await fetch(`${API}/tasks/${id}`);
          if (!resp.ok) return;
          const data = await resp.json();
          setSelectedTask(data.task);
          setLogs(data.logs || []);
        } catch (e) {
          console.error('Failed to fetch task detail:', e);
        }
      }, []);

      // Handle card click
      const handleSelect = useCallback((id) => {
        setSelectedId(id);
        fetchTaskDetail(id);
      }, [fetchTaskDetail]);

      // Close panel
      const handleClose = useCallback(() => {
        setSelectedId(null);
        setSelectedTask(null);
        setLogs([]);
      }, []);

      // Actions
      const handleCancel = useCallback(async (id) => {
        await fetch(`${API}/tasks/${id}/cancel`, { method: 'POST' });
        fetchTasks();
        fetchTaskDetail(id);
      }, [fetchTasks, fetchTaskDetail]);

      const handleRetry = useCallback(async (id) => {
        await fetch(`${API}/tasks/${id}/retry`, { method: 'POST' });
        fetchTasks();
        fetchTaskDetail(id);
      }, [fetchTasks, fetchTaskDetail]);

      const handleDelete = useCallback(async (id) => {
        await fetch(`${API}/tasks/${id}`, { method: 'DELETE' });
        fetchTasks();
        handleClose();
      }, [fetchTasks, handleClose]);

      // WebSocket
      useEffect(() => {
        function connect() {
          const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
          const socket = new WebSocket(`${proto}//${location.host}/ws`);

          socket.onopen = () => setWsConnected(true);

          socket.onclose = () => {
            setWsConnected(false);
            setTimeout(connect, 3000);
          };

          socket.onerror = () => socket.close();

          socket.onmessage = (event) => {
            try {
              const msg = JSON.parse(event.data);
              // Refresh task list on any event
              fetchTasks();
              // If the side panel is open for this task, refresh its detail
              setSelectedId(current => {
                if (current === msg.task_id) {
                  fetchTaskDetail(msg.task_id);
                }
                return current;
              });
            } catch (e) {
              console.error('WS parse error:', e);
            }
          };

          wsRef.current = socket;
        }

        connect();
        return () => {
          if (wsRef.current) wsRef.current.close();
        };
      }, [fetchTasks, fetchTaskDetail]);

      // Initial fetch
      useEffect(() => { fetchTasks(); }, [fetchTasks]);

      // Escape key to close panel
      useEffect(() => {
        const handler = (e) => {
          if (e.key === 'Escape') handleClose();
        };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [handleClose]);

      // Compute total cost
      const totalCost = tasks.reduce((sum, t) => sum + (t.cost_usd || 0), 0);

      return (
        <React.Fragment>
          <header>
            <h1>Claude Code Manager</h1>
            <div className="header-right">
              <span className="cost-summary">
                {tasks.length} task{tasks.length !== 1 ? 's' : ''} &middot; ${totalCost.toFixed(4)}
              </span>
              <div className="ws-status">
                <div className={`ws-dot${wsConnected ? ' connected' : ''}`} />
                <span>{wsConnected ? 'Connected' : 'Disconnected'}</span>
              </div>
            </div>
          </header>

          <CreateForm onCreated={fetchTasks} tasks={tasks} />

          <div className="kanban-board">
            {COLUMNS.map(col => (
              <KanbanColumn
                key={col.key}
                column={col}
                tasks={tasks}
                selectedId={selectedId}
                onSelect={handleSelect}
              />
            ))}
          </div>

          {selectedTask && (
            <SidePanel
              task={selectedTask}
              logs={logs}
              onClose={handleClose}
              onCancel={handleCancel}
              onRetry={handleRetry}
              onDelete={handleDelete}
            />
          )}
        </React.Fragment>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(() => {});
    }
  </script>
</body>
</html>
